#!/usr/bin/env python3

import socket
from threading import Thread
import ast
from time import sleep
from datetime import datetime
import re
import sys

from Server import Server

class Client:
  def __init__(self, name, server_ip, server_port, client_port):
    self.name = name
    self.server_ip = server_ip
    self.server_port = server_port
    self.client_port = client_port
    self.curr_seq = 0
    self.waiting_ack = set()
    self.all_clients = {}
    self.alive = True
    if client_port < 1024 or client_port > 65535:
      print('[Error: given client port invalid, program quit]')
      return
    if server_port < 1024 or server_port > 65535:
      print('[Error: given server port invalid, program quit]')
      return
    ip_check = server_ip.split('.')
    if len(ip_check) != 4:
      print('[Error: given server ip format wrong, program quit]')
      return
    for i in range(4):
      if not ip_check[i].isnumeric():
        print('[Error: non-number in given server ip, program quit]')
        return
    self.alive = True
    self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    self.socket.bind(('', int(client_port)))
    listening_thread = Thread(target=self.listen)
    listening_thread.start()
    self.send_registration()
    self.handle_input()
    


  def send_registration(self):
    self.alive = True
    message = {}
    message['type'] = 'registration'
    message['seq'] = self.curr_seq
    curr_seq = self.curr_seq
    self.curr_seq += 1
    message['client_name'] = self.name
    
    self.waiting_ack.add(curr_seq)

    self.socket.sendto(str(message).encode(), (self.server_ip, self.server_port))
    sleep(0.1)

    if curr_seq not in self.waiting_ack:
      print('>>> [Welcome, You are registered.]')
    else:
      succeeded = False
      for i in range(5):
        print(f'>>> [retrying sending registration info {i + 1}th time]')
        self.socket.sendto(str(message).encode(), (self.server_ip, self.server_port))
        sleep(0.1)
        if curr_seq not in self.waiting_ack:
          print('>>> [Welcome, You are registered.]')
          succeeded = True
          break
      if not succeeded:
        self.alive = False
        print('>>> [server not responding]')
    

  def listen(self):
    while True:
      message_and_address = self.socket.recvfrom(2048)
      message = ast.literal_eval(message_and_address[0].decode())
      address = message_and_address[1]
      if not self.alive:
        continue
      if message['type'] == 'update_table':
        self.all_clients = message['all_clients']
        print('>>> [Client table updated.]')
        confirm_update_message = {}
        confirm_update_message['type'] = 'ack_upon_update'
        confirm_update_message['seq'] = message['seq']
        self.socket.sendto(str(confirm_update_message).encode(), (address[0], int(address[1]))) # sends the ACK upon updating table and that's it
      elif message['type'] == 'confirm_registration':
        self.waiting_ack.remove(message['seq'])
      elif message['type'] == 'confirm_direct_message':
        self.waiting_ack.remove(message['seq'])
      elif message['type'] == 'confirm_direct_offline_message_from_server':
        self.waiting_ack.remove(message['seq'])
      elif message['type'] == 'direct_message':
        sender = message['from']
        message_content = message['content']
        print(f'>>> {sender}: {message_content}')
        confirm_direct_message = {}
        confirm_direct_message['type'] = 'confirm_direct_message'
        confirm_direct_message['seq'] = message['seq']
        self.socket.sendto(str(confirm_direct_message).encode(), (address[0], int(address[1])))
      elif message['type'] == 'confirm_dereg':
        self.waiting_ack.remove(message['seq'])
      elif message['type'] == 'check_receiver':
        confirm_receiver = {}
        confirm_receiver['type'] = 'confirm_receiver'
        confirm_receiver['seq'] = message['seq']
        self.socket.sendto(str(confirm_receiver).encode(), (address[0], int(address[1])))
      elif message['type'] == 'note_receiver_not_dead':
        receiver = message['receiver_name']
        print(f'>>> [Client {receiver} exists!!]')
        self.all_clients[receiver]['status'] = True
        print('>>> [Client table updated.]')
      elif message['type'] == 'makeup_message_to_receiver':
        sender = message['from']
        message_content = message['content']
        print(f'>>> {sender}: {message_content}')
        confirm_makeup_message = {}
        confirm_makeup_message['type'] = 'confirm_makeup_message'
        confirm_makeup_message['seq'] = message['seq']
        self.socket.sendto(str(confirm_makeup_message).encode(), (address[0], int(address[1])))
      elif message['type'] == 'confirm_offline_message_save':
        timestamp = message['timestamp']
        print(f'>>> [Offline Message sent at {timestamp} received by the server and saved.]')
      elif message['type'] == 'offline_message_upon_reg':
        message_list = message['all_messages']
        print('>>> [You have offline messages:]')
        for each in message_list:
          sender = each['from']
          timestamp = each['timestamp']
          message_content = each['content']
          print(f'>>> {sender}: {timestamp} {message_content}')
        confirm_offline_message_upon_reg = {}
        confirm_offline_message_upon_reg['type'] = 'confirm_offline_message_upon_reg'
        confirm_offline_message_upon_reg['seq'] = message['seq']
        self.socket.sendto(str(confirm_offline_message_upon_reg).encode(), (address[0], int(address[1])))
      elif message['type'] == 'delivery_confirmation':
        receiver = message['receiver']
        timestamp = message['timestamp']
        # if 
        print(f'11>>> [Offline Message sent at {timestamp} received by {receiver}.]')
        ack_upon_delivery_confirmation = {}
        ack_upon_delivery_confirmation['type'] = 'ack_upon_delivery_confirmation'
        ack_upon_delivery_confirmation['seq'] = message['seq']
        self.socket.sendto(str(ack_upon_delivery_confirmation).encode(), (address[0], int(address[1])))
      elif message['type'] == 'confirm_group_message':
        self.waiting_ack.remove(message['seq'])
      elif message['type'] == 'group_chat_message_sending':
        send_from = message['from']
        message_content = message['content']
        print(f"Group Chat {send_from}: {message_content}.")
        ack_group_message = {}
        ack_group_message['type'] = 'ack_group_message'
        ack_group_message['seq'] = message['seq']
        self.socket.sendto(str(ack_group_message).encode(), (address[0], int(address[1])))

  def handle_input(self):
    while True:
      new_input = input()
      # sending a message
      
      if bool(re.match(r"send .*", new_input)):
        new_input = new_input[5:]
        match = re.match(r"^(\w+)\s(.+)$", new_input)
        if not self.alive:
          print('>>> [you are not alive yet]')
          continue
        if match:
          dst, message_content = match.groups()
          if dst not in self.all_clients:
            print('>>> [invalid destination]')
            continue
          message = {}
          message['type'] = 'direct_message'
          message['seq'] = self.curr_seq
          seq_number = self.curr_seq
          self.curr_seq += 1
          message['from'] = self.name
          message['to'] = dst
          message['content'] = message_content
          direct_message_thread = Thread(target=self.direct_message, args=(message, seq_number,))
          direct_message_thread.start()
        else:
          print('<<< [invalid send input]')
      elif new_input == 'dereg':
        message = {}
        message['type'] = 'deregister'
        message['seq'] = self.curr_seq
        message['client_name'] = self.name
        seq_number = self.curr_seq
        self.curr_seq += 1
        dereg_thread = Thread(target=self.deregister, args=(message, seq_number,))
        dereg_thread.start()
      elif new_input == 'reg':
        self.send_registration()
      elif bool(re.match(r'send_all .*', new_input)):
        if not self.alive:
          print('>>> [you are not alive yet]')
          continue
        new_input = new_input[9:]
        message = {}
        message['type'] = 'group_message'
        message['seq'] = self.curr_seq
        curr_seq = self.curr_seq
        self.curr_seq += 1
        message['from'] = self.name
        message['timestamp'] = str(datetime.now())[:-7]
        message['content'] = new_input
        group_message_thread = Thread(target=self.group_message, args=(message, curr_seq,))
        group_message_thread.start()
      else:
        print('>>> [Invalid command]')

  def group_message(self, message_dic, curr_seq):
    self.waiting_ack.add(curr_seq)
    self.socket.sendto(str(message_dic).encode(), (self.server_ip, self.server_port))
    sleep(0.1)
    if curr_seq not in self.waiting_ack:
      print(">>> [Group Message received by Server.]")
    else:
      success = False
      for i in range(5):
        print(f'>>> [retrying sending group message request {i + 1}th time]')
        self.socket.sendto(str(message_dic).encode(), (self.server_ip, self.server_port))
        sleep(0.1)
        if curr_seq not in self.waiting_ack:
          print(">>> [Group Message received by Server.]")
          success = True
          break
      if not success:
        print('>>> [Server not responding.]')
      


  def deregister(self, message_dic, seq_num):
    self.socket.sendto(str(message_dic).encode(), (self.server_ip, self.server_port))
    self.waiting_ack.add(seq_num)
    sleep(0.1)
    if seq_num not in self.waiting_ack:
      print(">>> [You are Offline. Bye.]")
    else:
      succeeded = False
      for i in range(5):
        print(f'>>> [retrying sending dereg request {i + 1}th time]')
        self.socket.sendto(str(message_dic).encode(), (self.server_ip, self.server_port))
        sleep(0.1)
        if seq_num not in self.waiting_ack:
            print('>>> [You are Offline. Bye.]')
            succeeded = True
            break
      if not succeeded:
        print(">>> [Server not responding]")
        print(">>> [Exiting]")
    self.alive = False


  def direct_message(self, message_dic, seq_num):
    to_name = message_dic['to']
    # if when according to local table, the receiver is inactive
    if not self.all_clients[to_name]['status']:
      message_to_server = {}
      message_to_server['type'] = 'offline_message'
      message_to_server['seq'] = self.curr_seq
      message_to_server['timestamp'] = str(datetime.now())[:-7]
      curr_seq = self.curr_seq
      self.curr_seq += 1
      message_to_server['from'] = message_dic['from']
      message_to_server['to'] = message_dic['to']
      message_to_server['content'] = message_dic['content']
      self.waiting_ack.add(curr_seq)
      self.socket.sendto(str(message_to_server).encode(), (self.server_ip, self.server_port))
      sleep(0.1)
      if curr_seq not in self.waiting_ack:
        print(f'>>> [No ACK from {to_name}, message sent to server.]')
      else:
        succeeded = False
        for i in range(5):
          print(f'>>> [retrying sending offline message to the server {i + 1}th time]')
          self.socket.sendto(str(message_to_server).encode(), (self.server_ip, self.server_port))
          sleep(0.1)
          if curr_seq not in self.waiting_ack:
            print(f'>>> [No ACK from {to_name}, message sent to server.]')
            succeeded = True
            break
        if not succeeded:
          print('>>> [server not responding, give up sending offline message]')
    # if the receiver is still active according to the local table
    else:
      self.socket.sendto(str(message_dic).encode(), (self.all_clients[to_name]['ip'],self.all_clients[to_name]['port']))
      self.waiting_ack.add(seq_num)
      sleep(0.1)
      if seq_num not in self.waiting_ack:
        print(f'>>> [Message received by {to_name}.]')
      else:
        message_to_server = {}
        message_to_server['type'] = 'offline_message'
        message_to_server['seq'] = self.curr_seq
        curr_seq = self.curr_seq
        self.curr_seq += 1
        message_to_server['from'] = message_dic['from']
        message_to_server['timestamp'] = str(datetime.now())[:-7]
        message_to_server['to'] = message_dic['to']
        message_to_server['content'] = message_dic['content']
        self.socket.sendto(str(message_to_server).encode(), (self.server_ip, self.server_port))
        self.waiting_ack.add(curr_seq)
        sleep(0.1)
        if curr_seq not in self.waiting_ack:
          print(f'>>> [No ACK from {to_name}, message sent to server.]')
        else:
          succeeded = False
          for i in range(5):
            print(f'>>> [retrying sending offline message to the server {i + 1}th time]')
            self.socket.sendto(str(message_to_server).encode(), (self.server_ip, self.server_port))
            sleep(0.1)
            if self.curr_seq not in self.waiting_ack:
              print(f'>>> [No ACK from {to_name}, message sent to server.]')
              succeeded = True
              break
          if not succeeded:
            print('>>> [server not responding, give up sending offline message]')



      


if __name__ == "__main__":
  input_count = len(sys.argv) - 1
  if input_count == 2:
    mode = sys.argv[1]
    if mode == '-s':
      port_num = sys.argv[2]
      if not port_num.isnumeric():
        print('invalid input')
      else:
        server = Server(int(port_num))
    else:
      print('invalid input')
  elif input_count == 5:
    mode = sys.argv[1]
    name = sys.argv[2]
    server_ip = sys.argv[3]
    server_port = sys.argv[4]
    client_port = sys.argv[5]
    if mode == '-c':
      if not server_port.isnumeric() or not client_port.isnumeric():
        print('invalid input')
      else:
        client = Client(name, server_ip, int(server_port), int(client_port))
    else:
      print('invalid input')
  else:
    print('invalid input')